## 문자열 패턴 매칭
- 고지식한 패턴 검색 알고리즘, 카프-라빈 알고리즘, KMP 알고리즘, 보이어-무어 알고리즘
- 고지식한 알고리즘(Brute Force)
  - 본문 문자열을 처음부터 끝까지 차례대로 순회하면서 패턴 내의 문자들을 일일이 비교하는 방식으로 동작
- KMP 알고리즘
  - 불일치가 발생한 텍스트 스트링의 앞 부분에 어떤 문자가 있는지를 미리 알고 있으므로, 불일치가 발생한 앞 부분에 대하여 다시 비교하지 않고 매칭을 수행
  - 배턴을 전처리하여 배열 next[M]을 구해서 잘못된 시작을 최소화함
    - next[M] : 불일치가 발생했을 경우 이동할 다음 위치
  - 시간복잡도 : O(M+N)
- 보이어-무어 알고리즘
  - 오른쪽에서 왼쪽으로 비교
  - 대부분의 상용 소프트웨어에서 채택하고 있는 알고리즘
  - 보이어-무어 알고리즘은 패턴에 오른쪽 끝에 있는 문자가 불일치 하고 이 문자가 패턴 내에 존재하지 않는 경우, 이동 거리는 무려 패턴의 길이만큼이 된다.


## 탐욕(Greedy) 알고리즘
- 탐욕 알고리즘은 최적해를 구하는 데 사용되는 근시안적인 방법
- 최적화 문제(optimization)란 가능한 해들 중에서 가장 좋은(최대 또는 최소) 해를 찾는 문제이다.
- 일반적으로, 머리 속에 떠오르는 생각을 검증 없이 바로 구현하면 Greedy 접근이 된다.
- 여러 경우 중 하나를 선택 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달한다.
- 각 선택 시점에서 이루어지는결정은 지역적으로는 최적이지만, 그 선택들을 계속 수집하여 최종적인 해답을 만들었다고 하여, **그것이 최적이라는 보장은 없다.**
- 일단, 한번 선택된 것은 번복하지 않는다. 이런 특성 때문에 대부분의 탐욕 알고리즘들은 단순하며, 또한 제한적인 문제들에 적용된다.

- 탐욕적 선택 속성
  - 탐욕적 선택은 항상 최적이라는 보장이 없다.
  - 때문에 탐욕적 선택이 최적해로 갈 수 있음을 보여라.
  - 최적 부분 구조
    - 최적화 문제를 정형화하라 
    - 하나의 선택을 하면 풀어야 할 하나의 하위 문제가 남는다.
  - **[원문제의 최적해 = 탐욕적 선택 + 하위 문제의 최적해]** 임을 증명해야한다.


## 분할 정복 기법
- 분할(Divide) : 해결할 문제를 여러 개의 작은 부분으로 나눈다.
- 정복(Conquer) : 나눈 작은 문제를 각각 해결한다.
- 통합(Combine) : (필요하다면) 해결된 해답을 모은다.
