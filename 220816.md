## 재귀호출

- 함수 호출은 메모리 구조에서 스택을 사용한다.(이름만 같은 다른 메서드)
  - 간단한 문제에 대해서는 반복문에 비해 메모리 및 속도에서 성능저하가 발생한다.
- 일반적으로 기본 부분(Base case), 재귀 부분(Recursive case)로 구성된다.
  - Base case : 재귀 호출에서 빠져 나가기 위한 조건
  - Recursive case : 자신을 호출하는 부분 (Base case로 유도한다.)
- 재귀적 프로그램을 작성하는 것은 반복 구조에 비해 간결하고 이해하기 쉽다.
- 함수에서 실행해야 하는 작업의 특성에 따라 일반적인 호출방식보다 재귀호출방식을 사용하여 함수를 만들면 프로그램의 크기를 줄이고 간단하게 작성할 수 있다.
- Memoization을 적용하면 엄청난 중복 호출에도 실행시간을 줄일 수 있다.

<br></br>

## 우선순위 큐(Priority Queue)

- 우선순위 큐는 **우선순위가 가장 높은 데이터를 가장 먼저 삭제하는 자료구조입니다.**
- 우선순위 큐는 데이터를 **우선순위에 따라** 처리하고 싶을 때 사용합니다.
  - 예시) 물건 데이터를 자료구조에 넣었다가 가치가 높은 물건부터 꺼내서 확인해야 하는 경우
- 우선순위 큐를 구현하는 방법은 다양합니다.
  1. 단순히 리스트를 이용하여 구현
  2. 힙(heap)을 이용하여 구현
- 데이터의 개수가 N개일 때, 구현 방식에 따라서 시간 복잡도를 비교한 내용은 다음과 같습니다.
  
  | 우선순위 큐 구현 방식 | 삽입 시간 | 삭제 시간 |
  |:--- | :---- | ---- |
  | 리스트 | O(1) | O(N) |
  | 힙(Heap) | O(logN) | O(logN) |
- 단순히 N개의 데이터를 힙에 넣었다가 모두 꺼내는 작업은 정렬과 동일합니다. **(힙 정렬)**
  - 이 경우 시간 복잡도는 O(NlogN)입니다.

<br></br>

## 힙(Heap)의 특징

- 힙은 완전 이진 트리 자료구조의 일종입니다.
  - 완전 이진 트리(Complete Binary Tree)란 왼쪽 자식 노드, 오른쪽 자식 노드 순서대로 데이터가 차례대로 삽입되는 트리(tree)를 의미합니다.
- 힙에서는 항상 **루트 노드(root node)를 제거**합니다.
- 최소 힙(min heap)
  - 루트 노드가 가장 작은 값을 가집니다.
  - 따라서 값이 작은 데이터가 우선적으로 제거됩니다.
- 최대 힙(max heap)
  - 루트 노드가 가장 큰 값을 가집니다.
  - 따라서 값이 큰 데이터가 우선적으로 제거됩니다.

## 최소 힙 구성 함수 : Min-Heapify()

- (상향식) 부모 노드로 거슬러 올라가며, 부모보다 자신의 값이 더 작은 경우에 위치를 교체합니다.
- 새로운 원소가 삽입되었을 때 O(logN)의 시간 복잡도로 힘 성질을 유지하도록 할 수 있습니다.
- 힙에서 원소가 제거될 떄 O(logN)의 시간 복잡도로 힘 성질을 유지하도록 할 수 있습니다.
  - 원소를 제거할 때는 가장 마지막 노드가 루트 노드의 위치에 오도록 합니다.
  - 이후에 루트 노드에서부터 하향식으로(더 작은 자식 노드로) Heapify()를 진행합니다.

## 우선순위 큐 라이브러리를 활용한 힙 정렬 구현 예제

- python은 기본적으로 힙 자료구조는 min heap 형태로 동작.
- 만약 max heap 형태로 동작하는 힙 자료구조가 필요하다면, 데이터를 넣을 때와 데이터를 꺼낼때 -를 붙여서 데이터를 꺼내게 되면 max heap으로 동작하도록 만들 수 있습니다.

```python
import sys
import heapq
input = sys.stdin.readline

def heapsort(iterable):
  h = []
  result = []
  # 모든 원소를 차례대로 힙에 삽입
  for value in iterable:
    heapq.heappush(h,value)
  # 힙에 삽입된 모든 원소를 차례대로 꺼내어 담기
  for i in range(len(h)):
    result.append(heapq.heappop(h))
  return result

n = int(input())
arr = []

for i in range(n):
  arr.append(int(input()))

res = heapsort(arr)

for i in range(n):
  print(res[i])
```
